//: [Previous](@previous)

import Foundation

/*:
 # ARC
 
 안녕하세요.
 
 이번 챕터에서는 ARC(Automatic reference counting)에 대하여 알아보려고 합니다.
 
 
 
 여러분들은 앞의 챕터를 진행하시면서 많은 객체를 생성하셨습니다.
 
 객체가 생성되면 자동적으로 메모리에 값이 저장되게 되면서 메모리의 용량을 차지하게 되는데요.
 
 메모리의 총량은 한정되어있는데 계속 객체가 생성만 된다면 문제가 발생할 것입니다.
 
 이런 문제를 해결하기 위하여 메모리 관리에 대해서 알아보려고 합니다.
 
 
 
 지금부터 아래 내용을 잘 확인해주세요.
 
 아래 내용은 모두 Xcode 10, Swift 4.2 에서 작성되었습니다.
 
 [Nebori Swift Book](https://github.com/Nebori/NeboriSwiftBook)
 */

/*:
 ## 메모리 관리
 
 메모리는 한정된 자원입니다.
 
 한정된 자원을 계속해서 사용만 한다면 결국 자원은 부족하게 될 것이고, 해야하는 일을 못하게 될 것입니다.
 
 그렇다면 저희는 여태 메모리 관리를 해왔던 것일까요?
 
 한번도 메모리 관리 코드를 추가해본 적이 없는데?
 
 네, 스위프트는 기본적으로 자동 레퍼런스 카운팅을 이용하여 메모리 관리를 하고 있습니다.
 
 개발자가 따로 코드를 작성하지 않더라도 메모리 관리를 해주고 있죠.
 
 (다른 언어들도 ARC를 많이 이용하고 있습니다)
 */

/*:
 ### 레퍼런스 카운트
 
 레퍼런스 카운트는 쉽게말해 내 코드에서 객체를 참조하는 개수입니다.
 
 정확하게는 강한 참조의 개수입니다.
 
 객체를 사용, 즉 객체의 주소를 참조하는 곳이 1군데가 생기면 레퍼런스 카운트가 1이 증가하게 됩니다.
 
 반대로 객체가 사용종료, 즉 객체의 주소를 참조하는 곳이 1군데가 사라지면 레퍼런스 카운트가 1이 감소하게 되는거죠.
 
 이렇게 증감이 계속되다가 객체의 주소를 참조하는 곳이 0개가 되는 순간 사용이 끝났다고 판단하여 메모리가 해제됩니다.
 */

/*:
 ## 객체
 
 객체는 주소를 참조하는 것이기 때문에 클래스에만 적용이 됩니다.
 
 일반적은 값 타입에는 적용되지 않죠. (알고있는 구조체, 열거형)
 
 그렇다면 지금부터 코드와 함께 객체에 대해서 알아보도록 하겠습니다.
 
 */

 /*:
 ### 소유, 해제
 
 간단한 예제 클래스를 생성하고, 그 클래스의 객체를 만들었다가 해제하는 예제입니다.
 */

class ReferenceExam {
    init() {
        print("생성 되었습니다")
    }
    deinit {
        print("해제 되었습니다")
    }
}
var reference01: ReferenceExam! = ReferenceExam() // 여기서 레퍼런스 카운트가 +1 됩니다.
// 생성 되었습니다
reference01 = nil // 여기서 레퍼런스 카운트가 -1 됩니다.
// 해제 되었습니다.

/*:
 위에서 객체를 생성하는 부분에서 레퍼런스 카운트가 증가됩니다.
 
 해당 클래스를 참조하는 객체가 소유되면서 카운트가 +1 되는것이죠.
 
 아래 `nil` 을 대입하면서 더 이상 이 객체는 해당 클래스를 참조하지 않게 되면서 카운트가 -1 됩니다.
 
 결국 이 클래스는 아무도 참조하지 않게 되고 결국 메모리에서 해제당하고 맙니다.
 */

//: [Next](@next)
